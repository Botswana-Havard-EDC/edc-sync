
to disable add this to your settings.py

ALLOW_MODEL_SERIALIZATION = False  # (default: True)

###Configure a model for synchronization

To include a model add the `SyncModelMixin`. For example the base class for all CRFs in a module might look like this:


    class MaternalCrfModel(CrfModelMixin, SyncModelMixin, OffStudyMixin,
                                      RequiresConsentMixin, BaseUuidModel):
    
        consent_model = MaternalConsent
    
        off_study_model = ('mb_maternal', 'MaternalOffStudy')
    
        maternal_visit = models.OneToOneField(MaternalVisit)
    
        history = AuditTrail()
    
        entry_meta_data_manager = CrfMetaDataManager(MaternalVisit)
    
        def natural_key(self):
            return (self.maternal_visit.natural_key(), )
        natural_key.dependencies = ['mb_maternal.maternal_visit']
    
        def __unicode__(self):
            return unicode(self.get_visit())
    
        class Meta:
            abstract = True

        
`SyncModelMixin` needs model method `natural_key` and the model manager method `get_by_natural_key`. If either or both do not exist, a `SyncError` Exception is raises. In the example above, the `CrfModelMixin` declares the `objects` model manager that includes the required manager method.

`SyncModelMixin` creates `OutgoingTransaction` instances on the same DB as the model for all inserts, updates and deletes.

### Copy transactions from one DB to another

If data is entered on 'client' and needs to be synchronized to 'server', your `settings.DATABASES` might be like this:
    
    DATABASES = {
        'default': {},
        'server': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
        },
        'client': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
        }
    }
      
As data is entered on `client`, the data is serialized in order into model `OutgoingTransaction` on `client`. The outgoing transactions on `client` are copied to `server` like this:

    OutgoingTransaction.objects.using('client').filter(
            is_consumed_server=False).copy_to_incoming_transaction('server') 

Once the transactions are on `server` they are deserialized like this:

    messages = IncomingTransaction.objects.filter(
        is_consumed=False).deserialize(custom_device=device, check_hostname=False)

